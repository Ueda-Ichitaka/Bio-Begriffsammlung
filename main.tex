\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{minted}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{multicol}
\usepackage{upgreek}
\usepackage{graphicx}
\usepackage{color}

%\lstset{language=JVMIS}
\usemintedstyle{borland}
%\geometry{left=10mm, top=20mm, bottom=10mm}
\geometry{left=10mm, top=10mm, bottom=10mm}
\definecolor{mygreen}{rgb}{0,0.53,0}

\expandafter\def\csname PYGborland@tok@na\endcsname{\def\PYGborland@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}

\pagenumbering{gobble}

\lstset{
  keywordstyle=\bfseries,
  morekeywords={
    aload,aload_0,areturn,arraylength,astore,astore_0,getfield,getstatic,goto,
    goto_w,iadd,iand,iconst_0,idiv,if_icmpeq,if_icmpge,if_icmpgt,if_icmple,
    if_icmplt,if_icmpne,ifeq,ifge,ifgt,ifle,iflt,ifne,ifnonnull,ifnull,iinc,
    iload, iload_0,imul,ineg,instanceof,invokedynamic,invokeinterface,
    invokespecial,invokestatic,invokevirtual,ior,ireturn,ishl,ishr,istore,
    istore_0,isub,iushr,ixor,ldc,new,nop,pop,pop2,putfield,putstatic,ret,return,
    swap
  },
  sensitive=false,
  morecomment=[l]{##},
  commentstyle=\bfseries\color{mygreen},
  %morecomment=[s]{/*}{*/},
  %morestring=[b]",
}

\begin{document}


\section{Haskell}%
\begin{minted}{haskell}
digitsToInt :: [Char] -> Int
height :: Tree t -> Int --Höhe von binärem Baum
odds :: Integer t -> [t]
paths :: Tree t -> [[t]] --Liste aller Pfade durch binären Baum
primes :: Integer -> [Integer] --infinite list of primes
size :: Tree t -> Int --Anzahl Knoten in binärem Baum
\end{minted}
\vspace{-1mm}

\noindent\textbf{Prelude:}
\vspace{-2mm}
\begin{minted}{haskell}
all :: (a -> Bool) -> [a] -> Bool --True if all elements satisfy the predicate, False otherwise.
any :: (a -> Bool) -> [a] -> Bool --True if any element satisfies the predicate, and False otherwise.
break :: (a -> Bool) -> [a] -> ([a],[a]) --break where the predicate is first satisfied(snd empty if never).
chr :: Int -> Char
concat :: [[a]] -> [a] --folds nested list using foldr.
digitToInt :: Char -> Int
div :: Integral a => a -> a -> a --integer division of integral arguments.
dropWhile :: (a -> Bool) -> [a] -> [a] --drops while predicate is satisfied.
elem :: Eq a => a -> [a] -> Bool --True if element is in list
exp :: Floating a => a -> a --exponential function.
filter :: (a -> Bool) -> [a] -> [a] --returns list with all elements that satisfy predicate.
floor :: (RealFrac a, Integral b) => a -> b --returns the largest integer not greater than its argument.
foldl :: (a -> b -> a) -> a -> [b] -> a --fold list with operator and start value, left associative manner.
foldr :: (a -> b -> b) -> b -> [a] -> b --right associative manner.
fromInt :: Num a => Int -> a --Converts from Int to a numeric type which is in class Num.
fromInteger :: Num a => Integer -> a --Converts from Integer to a numeric type which is in class Num. 
fst :: (a, b) -> a
gcd :: Integral a => a -> a -> a
isAlpha :: Char -> Bool
isDigit :: Char -> Bool
iterate :: (a -> a) -> a -> [a] --iterate f x returns the infinite list [x,f(x),f(f(x)),...].
last :: [a] -> a --applied to a non empty list, returns the last element of the list.
lcm :: Integral a => a -> a -> a --returns the least common multiple of its two integral arguments.
length :: [a] -> Int
lines :: String -> [String] --split by newline.
log :: Floating a => a -> a
map :: (a -> b) -> [a] -> [b] --applies function to each element of list.
max :: Ord a => a -> a -> a
maximum :: Ord a => [a] -> a
min :: Ord a => a -> a -> a
minimum :: Ord a => [a] -> a
mod :: Integral a => a -> a -> a --returns the modulus of its two arguments.
notElem :: Eq a => a -> [a] -> Bool --False if element is in list.
not :: Bool -> Bool
null :: [a] -> Bool --returns True if its argument is the empty list and False otherwise.
ord :: Char -> Int --applied to a character, returns its ascii code as an
integer.
pred :: Enum a => a -> a --return predecessor.
product :: Num a => [a] -> a --applied to a list of numbers, returns their product.
repeat :: a -> [a] --return infinite list of same value.
replicate :: Int -> a -> [a] --repeats value specified number of times as list.
reverse :: [a] -> [a]
round :: (RealFrac a, Integral b) => a -> b --rounds its argument to the nearest integer.
show :: Show a => a -> String --converts value to its string representation.
snd :: (a, b) -> b --returns the second element of a two element tuple.
sort :: Ord a => [a] -> [a] --sorts its argument list in ascending order.
span :: (a -> Bool) -> [a] -> ([a],[a]) --splits list as takeWhile and rest.
splitAt :: Int -> [a] -> ([a],[a]) 
sqrt :: Floating a => a -> a
succ :: Enum a => a -> a --return successor.
sum :: Num a => [a] -> a --computes the sum of a finite list of numbers.
takeWhile :: (a -> Bool) -> [a] -> [a]
truncate :: (RealFrac a, Integral b) => a -> b --drops fractional part of float, returning only integral.
undefined :: a  --undefined value. It is a member of every type.
unlines :: [String] -> String
until :: (a -> Bool) -> (a -> a) -> a -> a --applies function to value until predicate is satisfied.
unwords :: [String] -> String --join with spaces.
words :: String -> [String] --split with spaces.
zip :: [a] -> [b] -> [(a,b)] --zip with comma.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
^,** --power for int,floats.
/=, ==, <=, >= --not equal, equal, less equal, greater equal

\end{minted}


\section{Prolog}
\begin{minted}{prolog}
allDifferent(L). %True, if all elements in L are different.
append(L1,L2,L). %append L1 and L2 in L.
delete(L1,X,L2). %delete X from L1 in L2 or get deleted X from L1 and L2.
digit(D). %True, if D is digit.
even(X). %True, if X is even.
fib(X,Y). %calculate X-th fibonacci in Y.
max(X,Y,Z). %get maximum from X and Y in Z.
member(X,L). %True, if X is in L.
nat(X). %infinite list of natural numbers.
odd(X). %True if X is odd.
permute(X,Y). %generate all permutations of X in Y.
qsort(X,Y). %sort X in Y.
rev(X,Y). %reverse X in Y.

is %assign value of right side to left side.

[Name1, Name2 | Names] %list notation
/,// %floating point, integer division
=<,>=,=:=,=\= %arithmetic comparison
\=,= %not unifiable, unification
\==,== %term comparison

\end{minted}

\newpage

%\newgeometry{left=10mm, top=10mm, bottom=20mm}


\section{Bytecode}
\begin{lstlisting}
aload/aload_0 to _3 #load a reference onto the stack from local variable
areturn #return a reference from a method
arraylength #get the length of an array
astore/aload_0 to _3 #store a reference into a local variable
getfield/getstatic #get (static) field value of object/class, by ref index in const pool
goto #goes to another instruction at branchoffset, eg: goto label
iadd #add two ints, take from stack
iand #perform bitwise and on two integers, take from stack
iconst_0 to _5 #load the int value 0 bis 5 onto the stack
idiv #divide two integers, take from stack

# ifxxx label => jump to label if condition is satisfied
if_icmpeq #if ints are equal, branch to instruction at branchoffset
if_icmpge #if fst is greater/equal to snd, branch to instruction at branchoffset
if_icmpgt #if fst is greater snd, branch to instruction at branchoffset
if_icmple #if fst is less/equal to snd, branch to instruction at branchoffset
if_icmplt #if fst is less than snd, branch to instruction at branchoffset
if_icmpne #if ints are not equal, branch to instruction at branchoffset
ifeq #if value is 0, branch to instruction at branchoffset
ifge #if value is greater/equal to 0, branch to instruction at branchoffset
ifgt #if value is greater than 0, branch to instruction at branchoffset
ifle #if value is less than/equal to 0, branch to instruction at branchoffset
iflt #if value is less than 0, branch to instruction at branchoffset
ifne #if value is not 0, branch to instruction at branchoffset
ifnonnull #if value is not null, branch to instruction at branchoffset
ifnull #if value is null, branch to instruction at branchoffset

iinc #increment local variable => iinc n x => increment var at n by x
iload/iload_0 to _3 #load an int value from a local variable on stack
imul #multiply two integers, take from stack
ineg #negate int, take from stack
instanceof #determines if object is of given type, by class ref in const pool

# ex: invokexxx Test.foo(I)I , I as int => I, void => V, boolean => Z
# or if "in constant pool at index n" then => invokexxx #n
invokedynamic #invokes dynamic method, puts result on stack, index in constant pool (arg)
invokeinterface #invokes interface method, puts result on stack, index in constant pool (arg)
invokespecial #invoke instance method, puts result on stack, index in constant pool (arg)
invokestatic #invoke a static method, puts result on stack, index in constant pool (arg)
invokevirtual #invoke virtual method, puts result on stack, index in constant pool (arg)

ior #bitwise int or, take from stack
ireturn #return an integer from a method, take from stack
ishl/ishr #int arithmetic shift left/right
istore/istore_0 to _3 #store int value into variable
isub #int subtract, take from stack
ixor #int xor, take from stack
ldc #push a constant on stack
new #create new object of type identified by class reference in constant pool index
nop #perform no operation
pop #discard the top value on the stack (pop2 for double or long)
putfield/putstatic #set (static) field to val in object/class, by ref index in const pool
ret #continue execution from address taken from a local variable
return #return void from method
swap #swaps two top words on stack (note that the words must not be double or long)
\end{lstlisting}

\newpage


\section{Lambda-Kalkül}
{\large
Lambda-Ausdrücke zu Church:\newline
$c_0~=~\lambda s.~\lambda z.~z$\newline
$c_1~=~\lambda s.~\lambda z.~s~z$\newline
$c_2~=~\lambda s.~\lambda z.~s~(s~z)$\newline
$pred~=~\lambda n.~n~(\lambda x.~\lambda f.~f~(x~c_0)~(succ~(x~c_0)))~(\lambda f.~f~c_0~c_0)~c_{true}$\newline
$succ~=~\lambda n.~\lambda s.~\lambda z.~s~(n~s~z)$\newline
$plus~=~\lambda m.~\lambda n.~\lambda s.~\lambda z.~m~s~(n~s~z)$\newline
$times~=~\lambda m.~\lambda n.~\lambda s.~n~(m~s)~\stackrel{\eta}{=}~\lambda m.~\lambda n.~\lambda s.~\lambda z.~n~(m~s)~z$\newline
$exp~=~\lambda m.~\lambda n.~n~m~\stackrel{\eta}{=}~\lambda m.~\lambda n.~\lambda s.~\lambda z.~n~m~s~z$\newline
$c_{true}~=~\lambda t.~\lambda f.~t$\newline
$c_{false}~=~\lambda t.~\lambda f.~f$\newline
$isZero~=~\lambda n.~n~(\lambda x.~c_{false})~c_{true}$\newline


\noindent$Y~=~\lambda f.~(\lambda x.~f~(x~x))~(\lambda x.~f~(x~x))$~\#Rekursionsoperator\newline
}
\vspace{1em}

\noindent
call-by-name:~reduziere linkesten äußersten Redex, der nicht von $\lambda$ umgeben\\
call-by-value:~reduziere linkesten äußersten Redex, der nicht von $\lambda$ umgeben und dessen Argument ein Wert ist\\
$\beta$-Reduktion: Entspricht Ausführung der Funktionsanwendung auf einem Redex\newline
Normalform: Term, der nicht weiter Reduziert werden kann\newline
$\alpha$-Äquivalenz:~$t_1$ und $t_2$ heißen $\alpha$-äquivalent ($t_1$ $\stackrel{\alpha}{=}$ $t_2$), wenn $t_1$ in $t_2$ durch konsistente Umbenennung der $\lambda$-gebundenen Variablen überführt werden kann.\newline
$\eta$-Äquivalenz: Terme $\lambda x.~f~x$ und $f$ heißen $\eta$-äquivalent $(\lambda x.~f~x~=~f)$, falls $x$ nicht freie Variable von $f$\newline

\vspace{3em}


\section{Typinferenz}

{\Large
\begin{multicols}{2}

\begin{prooftree}
\AxiomC{$c~\upepsilon~Const$}
\LeftLabel{CONST}
\UnaryInfC{$\Gamma\vdash c : \tau_c$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\vdash t : \tau'$}
\AxiomC{$\tau'\succeq\tau$}
\LeftLabel{VAR}
\BinaryInfC{$\Gamma\vdash t : \tau$}
\end{prooftree}

\end{multicols}

\begin{multicols}{2}

\begin{prooftree}
\AxiomC{$\Gamma,(x : \tau_1)\vdash t : \tau_2$}
\LeftLabel{ABS}
\UnaryInfC{$\Gamma\vdash\lambda x.t : \tau_1\rightarrow\tau_2$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\vdash f_1 : \tau_1\rightarrow\tau_2$}
\AxiomC{$\Gamma\vdash f_2 : \tau_1$}
\LeftLabel{APP}
\BinaryInfC{$\Gamma\vdash f_1~f_2 : \tau_2$}
\end{prooftree}

\end{multicols}

\begin{prooftree}
\AxiomC{$\Gamma\vdash t_1 : \tau_1$}
\AxiomC{$\Gamma,x:ta(\tau_1,\Gamma)\vdash t_2 : \tau_2$}
\LeftLabel{LET}
\BinaryInfC{$\Gamma\vdash let~x~=~t_1~in~t_2 : \tau_2$}
\end{prooftree}
}

\newpage

%\newgeometry{left=10mm, top=20mm, bottom=10mm}


\section{C}

\textbf{volatile:} no register or optimization, always fetch from main memory, useful if variable is accessed outside user program control (e.g. I/O buffers)

\subsection{MPI}

\begin{minted}{C}
MPI_Init(&argc, &argv);
int MPI_Comm_size(MPI_Comm comm, int* size)
int MPI_Comm_rank(MPI_Comm comm, int* rank)
int MPI_Send(void* buff, int count, MPI_Datatype dtype, int dst, int tag, MPI_Comm comm)
int MPI_Recv(void* buff, int count, MPI_Datatype dtype, int src, int tag, MPI_Comm comm, MPI_Status* stat)

//non-blocking send and receive
int MPI_Isend(void* buf, int count, MPI_Datatype type, int dst, int tag, MPI_Comm comm, MPI_Request* req)
int MPI_Irecv(void* buf, int count, MPI_Datatype type, int src, int tag, MPI_Comm comm, MPI_Request* req)
//non-blocking and blocking check for non-blocking send/receive
int MPI_Test(MPI_Request* r, int* flag, MPI_Status* s)
int MPI_Wait(MPI_Request* r, MPI_Status* s)

int MPI_Bcast(void* buffer, int count, MPI_Datatype t, int root, MPI_Comm comm)
int MPI_Scatter(void* sendbuf, int sendcount, MPI_Datatype sendtype, void* recvbuf,
                int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm)
int MPI_Gather(void* sendbuf, int sendcount, MPI_Datatype sendtype, void* recvbuf,
               int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm)
int MPI_Allgather(void* sendbuf, int sendcount, MPI_Datatype sendtype, void* recvbuf,
                  int recvcount, MPI_Datatype recvtype, MPI_Comm comm)
int MPI_Alltoall(void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf,
                 int recvcount, MPI_Datatype recvtype, MPI_Comm comm)

/* logical/bitwise and/or for reduce op: MPI_LAND, MPI_BAND, MPI_LOR, MPI_BOR, etc
                                         MPI_MAX, MPI_MIN, MPI_SUM, MPI_PROD, etc
   type for reduce op: MPI_INT, MPI_DOUBLE, etc*/
int MPI_Reduce(void* sendbuf, void* recvbuf, int count,
               MPI_Datatype type, MPI_Op op, int root, MPI_Comm comm)
//allows varying count of data to be send per process
int MPI_Scatterv(void* sendbuf, int* sendcounts, int* displacements, MPI_Datatype sendtype,
                 void* recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm)
\end{minted}

\includegraphics[scale=.4]{res/mpi}

\includegraphics[scale=.4]{res/mpi11}

\includegraphics[scale=.4]{res/mpi1}

\noindent
\textbf{MPI\texttt{\_}Send}: standard-mode blocking send\newline
\textbf{MPI\texttt{\_}Bsend}: buffered-mode blocking send\newline
\textbf{MPI\texttt{\_}Ssend}: synchronous-mode blocking send\newline
\textbf{MPI\texttt{\_}Rsend}: ready-mode blocking send\newline
\textbf{MPI\texttt{\_}Sendrecv} is blocking, but send buffers and receive buffers must be disjoint\newline
\textbf{MPI\texttt{\_}Sendrecv\texttt{\_}replace} available with one buffer for send and receive\newline

\newpage

%\newgeometry{left=10mm, top=10mm, bottom=20mm}


\section{Java}
%\usemintedstyle{abap}
memory consistency:\newline
1. if thread t1 caches variable v, thread t2 modifies it in main memory $\rightarrow$ t1 may not notice modification\newline
2. compiler optimization: Reordering of statements when the result of sequential intra-thread execution is not changed\newline

\subsection{classes/functions/syntax}

\begin{minted}[]{Java}
(int i, int j) -> i + j //lambda function, alternativ: (i, j) -> i + j

//alternative for loop notation
List<Integer> list = new ArrayList<T>(); int sum = 0;
for (int elem: list) { sum += elem; } //can be read as: for elem in list do ...

//java.util.ArrayList, implements interface List
List<T> list = new ArrayList<T>();
boolean add(T elem);
boolean add(int index, T elem);
void clear();
boolean contains(Object o);
T get(int index);
int indexOf(Object o);
boolean isEmpty();
T remove(Object o);
int size();

//java.util.HashSet, implements interface Set, note that Sets don't contain same value twice
Set<T> set = new HashSet<T>();
boolean add(T elem);
void clear();
boolean contains(Object o);
boolean isEmpty();
boolean remove(Object o);
int size();

//java.lang.Thread, implement getResult() to be able to access results
Thread t = new Thread(); //or new Thread(Runnable target);
void interrupt(); //can also be used from outside: thread.interrupt();
boolean isAlive();
boolean isInterrupted(); //eg use with if(isInterrupted()) break; in a while loop
void join();
void run(); //defines the task of a thread, executed sequentially if directly called
static void sleep(long millis); //need to catch InterruptedException around this, does not release monitor
void start(); //starts the thread

//example for passing Runnable to thread and immediately starting it
(new Thread(() -> {
    System.out.println("Hello");
})).start();

//code example for thread run() (run has to be implemented for Thread and Runnable class)
while(true) {
    if (isInterrupted()) break; //if thread has been interrupted, exit while loop
    //else: do stuff
    try { wait(); } catch(InterruptedException e) { interrupt(); }
}

//Callable<T> interface
T call(); //implementing class must implement call() method with return type T

//synchronization
thread.join();
synchronized(someObject) { doStuff(); } //synchronizes/locks on someObject
public synchronized func() { } //synchronizes/locks on this

//java.lang.Object, base class
void notify();
void notifyAll(); //recommended to use notifyAll() about notify(), wakes up all waiting threads
void wait(); //releases monitor, waits for notify, can throw InterruptedException that must be caught
void wait(long timeout);

//to avoid concurrency errors, defensive copies can be used, eg for lists:
java.util.Collections.unmodifiableList(someList); //will throw an error if someone tries to modify

//atomic types, AtomicInteger(empty constructor or with initial value):
int get(); //returns the variable
int incrementAndGet(); //atomically increments and returns the variable
int decrementAndGet(); //atomically decrements and returns the variable
boolean compareAndSet(int oldValue, int newValue); //checks for old value and replaces with new one

volatile int x; //introduces happens-before relationship between write and subsequent reads of a variable

//ReentrantLock()/ReentrantLock(boolean fair)
void lock();
boolean tryLock();
void unlock();

//semaphore/barrier
Semaphore(int capacity, boolean fair);
void acquire(); //takes permit an reduces number of available permits; blocks if all  are acquired
void release(); //releases and increases number of available permits; may release blocking acquirer
boolean tryAcquire(); //like acquire() but does not block

CyclicBarrier(int n); //calling await() blocks thread, after nth call, all threads resume
int await(); //InterruptedException, BrokenBarrierException must be caught

//Executor interface
void execute(Runnable runnable); //only starts one thread

//ExecutorService (subinterface of Executor) contains lifecycle logic
void execute(Runnable runnable);
static ExecutorService
boolean isShutdown(); //returns true if executor has been shut down
boolean isTerminated(); //returns true if all tasks have completed following shut down
void shutdown(); //initiates shutdown, already submitted tasks are executed, no new tasks are accepted
List<Runnable> shutdownNow() //stop/halt tasks that exec/wait, return list of tasks awaiting execution

//Executors class (not equal to Executor interface) provides factory methods to create ExecutorService:
static ExecutorService newSingleThreadExecutor() //creates Executor using single thread
static ExecutorService newFixedThreadPool(int n) //creates thread pool with reused threads of fixed size
static ExecutorService newCachedThreadPool() //creates thread pool with reused threads of dynamic size

//Future<T>
//submitting Callable<String> to existing executorService returns a Future<String>
Future<String> future = executorService.submit(()->{ return "HelloWorld"; });
String s = future.get(); //T get() blocks until thread finished and Future contains the value
//alternative: future.get(1, TimeUnit.SECONDS); to abort after 1 sec

//ScheduledExecutorService interface, use scheduleAtFixedRate for periodic execution of tasks
ScheduledFuture<?> schedule(Runnable task, long delay, TimeUnit timeunit); //single execution
ScheduledFuture<?> scheduleAtFixedRate(Runnable task, long initialDelay, long period, TimeUnit timeunit);

//CompletableFuture<T> to implement callbacks
static CompletableFuture<T> supplyAsync(Callable<T> task);
//calling on Future returned by supplyAsync:
CompletableFuture<T> thenApply(Callable<T> task); //returns new Future

//ForkJoinPool, can execute RecursiveAction/RecursiveTask which must override compute()
ForkJoinPool fjp = new ForkJoinPool();
fjp.invoke(definedtask); //for RecursiveAction(no result)/RecursiveTask(result) definedtask

//thread safe classe BlockingQueue<T> interface implemented by Array-/Linked-/PriorityBlockingQueue
void put(T t); //blocks if full
T take(); //blocks if empty
//ConcurrentHashMap<K,V> is also a thread safe class

//Stream<T>(interface), all Collection objects can call .stream() to return a Stream<T>
Stream<T> filter(Predicate<? super T> predicate) //returns stream of elements matching given predicate
stream.filter(Person::isStudent); //for given Stream<Person> and class Person with function isStudent()
IntStream mapToInt(ToIntFunction<? super T> mapper) //returns IntStream after applying function to elements
stream.mapToInt(Person::getAge); //for given Stream<Person> and class Person with function int getAge()
R collect(Supplier<R> supp,             //performs mutable reduction operation on elements of stream
          BiConsumer<R,? super T> accu, //supp: result container, accu: function to fold element in result
          BiConsumer<R,R> combiner);    //combiner: combines two values, must be compatible with result
//eg as:
stream.collect(() -> 0,
               (currentSum,person) -> { currentSum += person.getAge(); },
               (leftSum,rightSum) -> { leftSum += rightSum; });
//or same behavior with:
stream.collect(() -> new MutableInt(),
               (currentSum,person) -> { currentSum.add(person.getAge()); },
               (leftSum, rightSum) -> { leftSum.add(rightSum.intValue()); }).intValue();
//or collect with predefined functions (in this case group elements by age)
Map<Integer, List<Person>> map = stream.collect(Collectors.groupingBy(Person::getAge));

//parallel streams can be obtained from a Collection by calling parallelStream() equivalently to stream()
//collect can be executed in parallel if unordered and collector is concurrent:
Map<Integer, List<Person>> map = stream.collect(Collectors.groupingByConcurrent(Person::getAge));

\end{minted}

\newpage

\subsection{design by contract(JML)}

\subsubsection{Keywords}

requires: precondition\newline
ensures: postcondition\newline
\textbackslash old(X): old value of X, only available in postcondition\newline
\textbackslash result: return value, only available in postcondition

\subsubsection{Examples}

\begin{minted}[samepage]{Java}
//basic syntax, quantifiers(\forall, \exists)
/*@ requires size > 0;
  @ ensures \result != null && \result == \old(top());
  @ ensures (\forall int i; 0 <= i && i < size;
             \old(elements[i]) == elements[i]);
  @*/
Object pop() { ... pop logic ... }

class C { //class invariants
    //@ invariant size >= 0 && size <= 10;
    private int size = 0;
}
//methods used in contracts must be defined as pure to assure there are no side effects in contracts:
/*@ pure @*/ int getNum() { return size; }

/*@ private behavior //<= following lines belong to private behavior, neccessary for private variables
  @ requires size > 0;
  @*/
Object pop() { ... pop logic ... }

//alternative for using private variables is to specify the field as public only for the specification:
private /*@ spec_public @*/ int size = 0;

\end{minted}


\section{Sonstiges}

\subsection{Speedup}
{\huge$S(n)=\frac{T(1)}{T(n)}~=~\frac{1}{(1-p)+\frac{p}{n}}$}

\subsection{deadlocks}
Only occurs if all four Coffman conditions hold:\newline
\textbf{Mutual exclusion:} Only one thread can use an unshareable resource at one point of time. Further threads that need the resource have to wait.\newline
\textbf{Hold and wait:} A thread that already holds a resource requests access to additional resources (and must potentially wait for them).\newline
\textbf{No preemption:} A resource can only be released by the thread that holds it. Releasing a resource cannot be enforced from outside.\newline
\textbf{Circular wait:} A circular dependency between threads holding and requesting resources must exist. For threads $t_1$,..., $t_n$, each thread $t_i$ waits for a resource $t_{(i+1) mod n}$ is holding.\newline


\subsection{Umgekerte polnische Notation}

$7*4$ in UPN: $7~4~*$\newline
$a=a+1$ in UPN: $a~a~1~+~=$\newline
$2*(2+3)$ in UPN: $2~2~3~+~*$\newline


\end{document}